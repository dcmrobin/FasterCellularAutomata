#pragma kernel CSMain
#pragma kernel CSRandomInit
#pragma kernel CSMakeCellAlive
#pragma kernel CSMakeCellDead

RWTexture2D<float4> currentBuffer;
RWTexture2D<float4> nextBuffer;

StructuredBuffer<int2> clickBuffer; // Buffer to store click position
StructuredBuffer<float4> colorBuffer; // Buffer to store cell colors

bool pauseBool;
bool notDrawingBool;
uint brushRadius;
int width;
int height;

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    if (pauseBool)
        return;

    uint2 texDim;
    currentBuffer.GetDimensions(texDim.x, texDim.y);

    uint2 cellPos = id.xy;
    float4 current = currentBuffer[cellPos];

    // Count live neighbors
    int GoLcount = 0;
    int Seedscount = 0;
    int DayNightcount = 0;
    int Amoebacount = 0;
    int Highlifecount = 0;
    int Assimilationcount = 0;
    int Movecount = 0;
    int Diamoebacount = 0;
    int Mazecount = 0;
    int TwoXtwocount = 0;
    int PseudoLifecount = 0;
    int ThirtyFourcount = 0;
    int LongLifecount = 0;
    int Stainscount = 0;
    int Coagulationscount = 0;
    int WalledCitiescount = 0;
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (x == 0 && y == 0) continue;
            float4 neighbor = currentBuffer[clamp(cellPos + uint2(x, y), uint2(0, 0), texDim - uint2(1, 1))];
            GoLcount += int((neighbor.r == 1.0) && (neighbor.g == 1.0) && (neighbor.b == 1.0));
            Seedscount += int((neighbor.r == 1.0) && (neighbor.g == 0.8) && (neighbor.b == 0.0));
            DayNightcount += int((neighbor.r == 0.0) && (neighbor.g == 1.0) && (neighbor.b == 1.0));
            Amoebacount += int((neighbor.r == 1.0) && (neighbor.g == 0.0) && (neighbor.b == 1.0));
            Highlifecount += int((neighbor.r == 1.0) && (neighbor.g == 0.0) && (neighbor.b == 0.0));
            Assimilationcount += int((neighbor.r == 0.0) && (neighbor.g == 0.0) && (neighbor.b == 1.0));
            Movecount += int((neighbor.r == 0.0) && (neighbor.g == 1.0) && (neighbor.b == 0.0));
            Diamoebacount += int((neighbor.r == 0.4) && (neighbor.g == 0.0) && (neighbor.b == 0.0));
            Mazecount += int((neighbor.r == 0.6) && (neighbor.g == 1.0) && (neighbor.b == 0.6));
            TwoXtwocount += int((neighbor.r == 1.0) && (neighbor.g == 1.0) && (neighbor.b == 0.2));
            PseudoLifecount += int((neighbor.r == 1.0) && (neighbor.g == 0.2) && (neighbor.b == 0.0));
            ThirtyFourcount += int((neighbor.r == 0.2) && (neighbor.g == 0.0) && (neighbor.b == 0.2));
            LongLifecount += int((neighbor.r == 0.2) && (neighbor.g == 0.2) && (neighbor.b == 0.2));
            Stainscount += int((neighbor.r == 0.2) && (neighbor.g == 0) && (neighbor.b == 1));
            Coagulationscount += int((neighbor.r == 0.6) && (neighbor.g == 0.6) && (neighbor.b == 0));
            WalledCitiescount += int((neighbor.r == 0.2) && (neighbor.g == 0.2) && (neighbor.b == 0.8));
        }
    }

    // Use ternary operator and step function for rules
    float4 next = (current.r == 1 && current.g == 1 && current.b == 1) ?
        ((GoLcount < 2 || GoLcount > 3) ? 0.0 : float4(1, 1, 1, 1)) :
        (current.r == 1 && current.g == 0.8 && current.b == 0) ?
        0.0 :
        (current.r == 0 && current.g == 1 && current.b == 1) ?
        ((DayNightcount == 5 || DayNightcount < 3) ? 0.0 : float4(0, 1, 1, 1)) :
        (current.r == 1 && current.g == 0 && current.b == 1) ?
        ((Amoebacount == 0 || Amoebacount == 2 || Amoebacount == 4 || Amoebacount == 6 || Amoebacount == 7) ? 0.0 : float4(1, 0, 1, 1)) :
        (current.r == 1 && current.g == 0 && current.b == 0) ?
        ((Highlifecount < 2 || Highlifecount > 3) ? 0.0 : float4(1, 0, 0, 1)) :
        (current.r == 0 && current.g == 0 && current.b == 1) ?
        ((Assimilationcount < 4 || Assimilationcount > 7) ? 0.0 : float4(0, 0, 1, 1)) :
        (current.r == 0 && current.g == 1 && current.b == 0) ?
        ((Movecount != 2 && Movecount != 4 && Movecount != 5) ? 0.0 : float4(0, 1, 0, 1)) :
        (current.r == 0.4 && current.g == 0 && current.b == 0) ?
        ((Diamoebacount < 5 || Diamoebacount > 8) ? 0.0 : float4(0.4, 0, 0, 1)) :
        (current.r == 0.6 && current.g == 1 && current.b == 0.6) ?
        ((Mazecount < 1 || Mazecount > 5) ? 0.0 : float4(0.6, 1, 0.6, 1)) :
        (current.r == 1 && current.g == 1 && current.b == 0.2) ?
        ((TwoXtwocount != 1 && TwoXtwocount != 2 && TwoXtwocount != 5) ? 0.0 : float4(1, 1, 0.2, 1)) :
        (current.r == 1 && current.g == 0.2 && current.b == 0) ?
        ((PseudoLifecount != 2 && PseudoLifecount != 3 && PseudoLifecount != 8) ? 0.0 : float4(1, 0.2, 0, 1)) :
        (current.r == 0.2 && current.g == 0 && current.b == 0.2) ?
        ((ThirtyFourcount != 3 && ThirtyFourcount != 4) ? 0.0 : float4(0.2, 0, 0.2, 1)) :
        (current.r == 0.2 && current.g == 0.2 && current.b == 0.2) ?
        ((LongLifecount != 5) ? 0.0 : float4(0.2, 0.2, 0.2, 1)) :
        (current.r == 0.2 && current.g == 0 && current.b == 1) ?
        ((Stainscount == 0 || Stainscount == 1 || Stainscount == 4) ? 0.0 : float4(0.2, 0, 1, 1)) :
        (current.r == 0.6 && current.g == 0.6 && current.b == 0) ?
        ((Coagulationscount == 0 || Coagulationscount == 1 || Coagulationscount == 4) ? 0.0 : float4(0.6, 0.6, 0, 1)) :
        (current.r == 0.2 && current.g == 0.2 && current.b == 0.8) ?
        ((WalledCitiescount < 2 || WalledCitiescount > 5) ? 0.0 : float4(0.2, 0.2, 0.8, 1)) :
        // if cell is dead
        ((GoLcount == 3) ? float4(1, 1, 1, 1) :
         (Seedscount == 2) ? float4(1, 0.8, 0, 1) :
         (DayNightcount == 3 || DayNightcount == 6 || DayNightcount == 7 || DayNightcount == 8) ? float4(0, 1, 1, 1) :
         (Amoebacount == 3 || Amoebacount == 5 || Amoebacount == 7) ? float4(1, 0, 1, 1) :
         (Highlifecount == 3 || Highlifecount == 6) ? float4(1, 0, 0, 1) :
         (Assimilationcount >= 3 && Assimilationcount <= 5) ? float4(0, 0, 1, 1) :
         (Movecount == 3 || Movecount == 6 || Movecount == 8) ? float4(0, 1, 0, 1) :
         (Diamoebacount >= 5 && Diamoebacount <= 8 || Diamoebacount == 3) ? float4(0.4, 0, 0, 1) :
         (Mazecount == 3) ? float4(0.6, 1, 0.6, 1) :
         (TwoXtwocount == 3 || TwoXtwocount == 6) ? float4(1, 1, 0.2, 1) :
         (PseudoLifecount == 3 || PseudoLifecount == 5 || PseudoLifecount == 7) ? float4(1, 0.2, 0, 1) :
         (ThirtyFourcount == 3 || ThirtyFourcount == 4) ? float4(0.2, 0, 0.2, 1) :
         (LongLifecount >= 3 && LongLifecount <= 5) ? float4(0.2, 0.2, 0.2, 1) :
         (Stainscount == 3 || Stainscount >= 6 && Stainscount <= 8) ? float4(0.2, 0, 1, 1) :
         (Coagulationscount == 3 || Coagulationscount == 7 || Coagulationscount == 8) ? float4(0.6, 0.6, 0, 1) :
         (WalledCitiescount >= 4 && WalledCitiescount <= 8) ? float4(0.2, 0.2, 0.8, 1) : 0.0);

    nextBuffer[cellPos] = next;
}

[numthreads(16, 16, 1)]
void CSRandomInit(uint3 id : SV_DispatchThreadID) {
    // Seed the pseudo-random number generator with thread ID
    uint seed = ((id.x & 0xFF) << 24) | ((id.y & 0xFF) << 16) | (id.z & 0xFFFF);

    // Use a simple pseudo-random algorithm (XORSHIFT) to generate a value between 0 and 1
    uint randState = seed;
    randState ^= randState << 13;
    randState ^= randState >> 17;
    randState ^= randState << 5;

    float randomValue = float(randState & 0xFFFFFF) / float(0xFFFFFF);

    // Set the cell state based on the random value
    currentBuffer[id.xy] = (randomValue > 0.5) ? 1.0 : 0.0;
}

[numthreads(2, 2, 1)]
void CSMakeCellAlive() {
    if (notDrawingBool)
        return;

    // Read click position from buffer
    int2 clickPos = clickBuffer[0];

    // Apply brush size
    int halfBrushSize = brushRadius / 2;

    // Iterate over the cells in the neighborhood of the clicked point
    for (int i = clickPos.x - halfBrushSize; i <= clickPos.x + halfBrushSize; i++) {
        for (int j = clickPos.y - halfBrushSize; j <= clickPos.y + halfBrushSize; j++) {
            // Check if the current position is within the bounds of the texture
            if (i >= 0 && i < width && j >= 0 && j < height) {
                currentBuffer[int2(i, j)] = float4(colorBuffer[0]);
            }
        }
    }
}

[numthreads(2, 2, 1)]
void CSMakeCellDead() {
    if (notDrawingBool)
        return;

    // Read click position from buffer
    int2 clickPos = clickBuffer[0];

    // Apply brush size
    int halfBrushSize = brushRadius / 2;

    // Iterate over the cells in the neighborhood of the clicked point
    for (int i = clickPos.x - halfBrushSize; i <= clickPos.x + halfBrushSize; i++) {
        for (int j = clickPos.y - halfBrushSize; j <= clickPos.y + halfBrushSize; j++) {
            // Check if the current position is within the bounds of the texture
            if (i >= 0 && i < width && j >= 0 && j < height) {
                currentBuffer[int2(i, j)] = 0.0;
            }
        }
    }
}
